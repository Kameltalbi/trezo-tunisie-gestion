
import { toast } from "@/hooks/use-toast";
import { Transaction } from "@/types";

// Types for our database models
export interface Prevision {
  id: string;
  title: string;
  amount: number;
  date: string;
  category: string;
  type: 'in' | 'out'; // 'in' for income, 'out' for expense
  status: 'en_attente' | 'validée' | 'cancelled';
  linked_transaction_id?: string;
  compte_id?: string;
  projet_id?: string;
}

export interface CompteBancaire {
  id: string;
  name: string;
  solde_initial: number;
  solde_actuel: number;
  currency: string;
}

// Mock API function - replace with actual Supabase calls
const mockApiCall = (success = true): Promise<any> => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (success) {
        resolve({ success: true });
      } else {
        reject(new Error("API call failed"));
      }
    }, 500);
  });
};

/**
 * Validates a forecast and transforms it into a transaction
 * @param previsionId ID of the forecast to validate
 * @returns Promise with the created transaction
 */
export const validerPrevision = async (prevision: Prevision): Promise<Transaction | null> => {
  try {
    // Step 1: In a real app, fetch the most up-to-date forecast data
    // const { data: prevision, error } = await supabase
    //   .from('previsions')
    //   .select('*')
    //   .eq('id', previsionId)
    //   .single();
    
    // if (error || !prevision) throw new Error("Prévision non trouvée");
    
    // Step 2: Create a transaction based on the forecast
    const newTransaction: Partial<Transaction> = {
      id: Math.random().toString(36).substring(2, 9), // In real app, this will be generated by the DB
      title: prevision.title,
      amount: prevision.amount,
      date: prevision.date,
      category: prevision.category,
      type: prevision.type === 'in' ? 'income' : 'expense',
      source: 'forecast',
      accountId: prevision.compte_id
    };
    
    // In a real app with Supabase, use a transaction to ensure atomicity
    // const { data: transaction, error: transactionError } = await supabase
    //   .from('transactions')
    //   .insert(newTransaction)
    //   .select()
    //   .single();
    
    // if (transactionError) throw new Error("Échec de création de la transaction");
    
    // Step 3: Mock API call (replace with actual Supabase calls)
    await mockApiCall();
    
    // Step 4: Update the forecast status and link it to the transaction
    // const { error: updateError } = await supabase
    //   .from('previsions')
    //   .update({
    //     status: 'validée',
    //     linked_transaction_id: transaction.id
    //   })
    //   .eq('id', previsionId);
    
    // if (updateError) throw new Error("Échec de mise à jour de la prévision");
    
    // Step 5: Update the account balance
    // let balanceUpdate = {};
    // if (prevision.compte_id) {
    //   const { data: compte } = await supabase
    //     .from('comptes_bancaires')
    //     .select('solde_actuel')
    //     .eq('id', prevision.compte_id)
    //     .single();
    
    //   if (compte) {
    //     const newBalance = prevision.type === 'in' 
    //       ? compte.solde_actuel + prevision.amount 
    //       : compte.solde_actuel - prevision.amount;
    
    //     const { error: balanceError } = await supabase
    //       .from('comptes_bancaires')
    //       .update({ solde_actuel: newBalance })
    //       .eq('id', prevision.compte_id);
    
    //     if (balanceError) throw new Error("Échec de mise à jour du solde du compte");
    //   }
    // }
    
    // Success toast notification
    toast({
      title: "Prévision validée avec succès",
      description: `${prevision.type === 'in' ? 'Encaissement' : 'Décaissement'} de ${prevision.amount} € enregistré.`,
      variant: "default",
    });
    
    return newTransaction as Transaction;
  } catch (error) {
    // Error handling
    console.error("Erreur lors de la validation de la prévision:", error);
    toast({
      title: "Échec de la validation",
      description: error instanceof Error ? error.message : "Une erreur est survenue",
      variant: "destructive",
    });
    
    // In a real app, implement rollback logic here if needed
    return null;
  }
};

/**
 * Transforms a forecast status to a readable format
 */
export const formatForecastStatus = (status: string): string => {
  switch (status) {
    case 'en_attente': return 'En attente';
    case 'validée': return 'Validée';
    case 'cancelled': return 'Annulée';
    default: return status;
  }
};
